观察者模式和发布订阅模式

> 两种模式是不同的模式。最大的区别就是调度的地方。 观察者模式和订阅者模式之间是存在依赖的 发布订阅由调度中心控制。 所以没有依赖关系



## 观察者模式

![border](http://images2015.cnblogs.com/blog/555379/201603/555379-20160313183429007-1351424959.png)



目标和观察者一样 都是基类。 目标提供一系列维护观察者的方法。观察者更新接口。具体观察者和具体目标继承各自的基类。 然后具体观察者把自己注册到具体目标里 具体目标发生变化时 调度观察者的更新方法。

简单来说 这里订阅者把自己想订阅的事情 注册到发布者里面。 

发布订阅是 订阅者把订阅的事件注册到调度中心。

```javascript
// 观察者列表
function ObserverList() {
    this.observerList = [];
}

ObserverList.prototype = {
    constructor: ObserverList,
    add: function(obj) {
        return this.observerList.push(obj);
    },
    count: function() {
        return this.observerList.length;
    },
    get: function(index) {
        if (index > -1 && index < this.observerList.length) {
            return this.observerList[index];
        }
    },
    indexOf: function(obj, startIndex) {
        var i = startIndex;
        while (i < this.observerList.length) {
            if (this.observerList[i] === obj) {
                return i;
            }
            i++;
        }
        return -1;
    },
    removeAt: function(index) {
        this.observerList.splice(index, 1);
    }
};

// 目标(发布者)
function Subject() {
    this.observers = new ObserverList();
}

Subject.prototype = {
    constructor: Subject,
    addObserver: function(observer) {
        this.observers.add(observer);
    },
    removeObserver: function(observer) {
        this.observers.removeAt(this.observers.indexOf(observer, 0));
    },
    // 订阅
    notify: function(context) {
        var observerCount = this.observers.count();
        for (var i = 0; i < observerCount; i++) {
            this.observer.get(i).update(context);
        }
    }
};

function Observer() {
    this.update = function() {
        // ....
    }
}
```







## 发布订阅模式

订阅者把自己想订阅的事件注册到调度中心，当该事件触发时候，发布者发布该事件到调度中心（顺带上下文），由调度中心统一调度订阅者注册到调度中心的处理代码。

![border](http://images2015.cnblogs.com/blog/555379/201603/555379-20160313183439366-1623019133.png)



```javascript
var pubsub = {};
(function(myObject) {
    // Storage for topics that can be broadcast
    // or listened to
    var topics = {};
    // An topic identifier
    var subUid = -1;
    // Publish or broadcast events of interest
    // with a specific topic name and arguments
    // such as the data to pass along
    myObject.publish = function( topic, args ) {
        if ( !topics[topic] ) {
            return false;
        }
        var subscribers = topics[topic],
            len = subscribers ? subscribers.length : 0;
        while (len--) {
            subscribers[len].func( topic, args );
        }
        return this;
    };
    // Subscribe to events of interest
    // with a specific topic name and a
    // callback function, to be executed
    // when the topic/event is observed
    myObject.subscribe = function( topic, func ) {
        if (!topics[topic]) {
            topics[topic] = [];
        }
        var token = ( ++subUid ).toString();
        topics[topic].push({
            token: token,
            func: func
        });
        return token;
    };
    // Unsubscribe from a specific
    // topic, based on a tokenized reference
    // to the subscription
    myObject.unsubscribe = function( token ) {
        for ( var m in topics ) {
            if ( topics[m] ) {
                for ( var i = 0, j = topics[m].length; i < j; i++ ) {
                    if ( topics[m][i].token === token ) {
                        topics[m].splice( i, 1 );
                        return token;
                    }
                }
            }
        }
        return this;
    };
}( pubsub ));
```



#### 模式案例补充

```javascript

  /**
   * 发布——订阅 
   * 发布者是一个 里面有个缓存列表 缓存订阅者(有一个方法来增加订阅者) 还有一个发布消息的方法 负责给订阅者发消息 
   */
  let shop = {
    clienlist: [], // 缓存列表
    addlisten: function(fn) {
      // 增加订阅者
      this.clienlist.push(fn);
    },
    trigger: function() {
      // 发布消息
      for (var i = 0, fn; fn = this.clienlist[i++];) {
        fn.apply(this, arguments);
      }
    }
  };

/*小明发布订阅*/
shop.addlisten(function(price,taste){
  console.log("小明发布的"+price+"元，"+taste+"味道的");
});
/*小龙发布订阅*/
shop.addlisten(function(price,taste){
  console.log("小龙发布的"+price+"元，"+taste+"味道的");
});   

shop.trigger(10, '椒盐');
```

上面的代码 有几个问题 如果小明不喜欢椒盐的 只有小龙喜欢 那么久应该只发送给小龙

```javascript
var shop = {
  clientList: {}, // 缓存列表
  /**
   * 增加订阅者
   * @key {string} 类型
   * @fn {function} 回调
   */
  addListen: function(key, fn) {
    if (!this.clientList[key]) {
      this.clientList[key] = [];
    }
    this.clientList[key].push(fn);
  },
  // 发布消息
  trigger: function() {
    var key = [].shift.call(arguments), // 取出消息类型
        fns = this.clientList[key]; // 取出该类型对应的消息集合

    if (!fns || fns.length === 0) {
      return false;
    }
    for (var i = 0, fn; fn = fns[i++];) {
      fn.apply(this. arguments);
    }
  },

  /**
   * 删除订阅
   * @key {String} 类型
   * @fn {Function} 回调
   */
  remove: function(key, fn) {
    var fns = this.clientList[key]; // 取出相应类型的消息集合
    if (!fns) {
      // 如果对应的key没有订阅直接返回
      return false;
    }
    // 如果没有传入具体的回调 表示取消所有订阅者
    if (!fn) {
      fns && (fns.length=0);
    } else {
      for (var l = fns.length - 1; l >= 0; l--) {
        // 遍历回调函数列表
        if (fn === fns[l]) {
          fns.splice(l, 1);
        }
      }
    }
  }
};

/*小明发布订阅*/
Sesamecakeshop.addlisten("焦糖",fn1=function(price,taste){
  console.log("小明发布的"+price+"元，"+taste+"味道的");
});
/*小龙发布订阅*/
Sesamecakeshop.addlisten("椒盐",function(price,taste){
  console.log("小龙发布的"+price+"元，"+taste+"味道的");
});        

Sesamecakeshop.trigger("椒盐",10,"椒盐");
Sesamecakeshop.remove("焦糖",fn1); //注意这里是按照地址引用的。如果传入匿名函数则删除不了
Sesamecakeshop.trigger("焦糖",40,"焦糖");
```



#### 案例介绍2 超级权限

不同的身份可以删除有不同的功能  可以删除修改任意用户 普通用户只能修改自己的账户信息 首先是用户身份验证 验证之后对应功能才可以显示

```javascript
/**
 * 登录发布-订阅模式
 */
let login = {
  clientList: {}, // 缓存列表
  /** 增加订阅者
   * key 类型 
   * fn 回调
   **/
  addlisten: function(key, fn) {
    // 判断是否有其他
    if (!this.clientList[key]) {
      this.clientList[key] = [];
    } 
    this.clientList[key].push(fn);
  },
  /**
   * 发布消息
   */
  trigger: function() {
    var key = [].shift.call(arguments); // 取出消息类型
    var fns = this.clientList[key]; // 取出该类型的对应的消息集合
    if(!fns || fns.length === 0) {
      return false;
    }
    for (var i = 0, fn; fn = fns[i++];) {
      fn.apply(this, arguments);
    }
  }
};

// 超级管理员
var editall = (function(){
  login.addlisten('loginsucc', function(data){
    editall.setview(data);
  });
  return {
    setview: function(data) {
      console.log(data);
      console.log('超级管理员修改所有用户名');
    }
  }
}());

//仅仅修改自己
var editOwn=(function(){
  login.addlisten("loginsucc",function(data){
      editOwn.setview(data);
  });
  return{
      setview:function(data){
          console.log(data);
          console.log("仅仅修改自己");
      }
  }
})();
```



#### 简单封装

```javascript
var _Event=(function(){
    var clienlist={},
    addlisten,trigger,remove;
    /**
     * 增加订阅者
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    addlisten=function(key,fn){
        if(!clienlist[key]){
            clienlist[key]=[];
        }
        clienlist[key].push(fn);
    };
    /**
     * 发布消息
     * */
    trigger=function(){
        var key=[].shift.call(arguments),//取出消息类型
            fns=clienlist[key];//取出该类型的对应的消息集合
        if(!fns || fns.length===0){
            return false;
        }
        for(var i=0,fn;fn=fns[i++];){
            fn.apply(this,arguments);
        }
    };
    /**
     * 删除订阅
     * @key {String} 类型
     * @fn {Function} 回掉函数
     * */
    remove=function(key,fn){
        var fns=clienlist[key];//取出该类型的对应的消息集合
        if(!fns){//如果对应的key没有订阅直接返回
            return false;
        }
        if(!fn){//如果没有传入具体的回掉，则表示需要取消所有订阅
            fns && (fns.length=0);
        }else{
            for(var l=fns.length-1;l>=0;l--){//遍历回掉函数列表
                if(fn===fns[l]){
                    fns.splice(l,1);//删除订阅者的回掉
                }
            }
        }
    };
    return{
        addlisten:addlisten,
        trigger:trigger,
        remove:remove
    }
})();


_Event.addlisten("syo",function(d,all){
    console.log("发布的消息来自："+d+"，具体信息："+all);
});

_Event.addlisten("syo",function(d,all){
    console.log("发布的消息来自："+d+"，具体信息："+all);
});

_Event.trigger("syo", "石瑶","前端工程师");
```

