

### 性能优化的几个方面

* 1 优先优化对性能影响大的部分

  ​

* 2 对高频触发的事件进行节流或去抖

  * debounce 去抖（**对于一定时间段的连续的函数调用 只让其执行一次**）

    比如用户输入内容进行校验的场景

    ​

  * throttle 节流 （**让一个函数不要执行的太频繁 减少一些过快的频率来节流 核心是降低触发回调的频率**）

  ```javasc
  // 节流后的函数作为回调
  $(window).on('scroll', _.throttle(doSomething, 200));

  ```

  ​

* 3  优化CSS 

  因为CSS 选择器在匹配的时候 是右向左的。 最后一个选择器被称为关键选择器。

  ​

* script标签

  * CSS可能会阻塞解析， 取决于外部样式表和脚本在文档中的顺序。 如果在文档外部样式表放置脚本之前，DOM对象和CSSDOM对象的构建可以互相干扰。 当解析器获取到一个script 标签。 DOM 将无法继续构建直到JavaScript执行完毕。

  * defer 和 async

    **不是很重要的脚本，例如监测和分析的脚本 可以异步去加载他们。**

    defer 是加载文档元素的过程将和js的加载并行。但是执行要在所有元素解析完成之后。 DOMContentLoaded事件触发之前完成。

    async 的脚本在下载完成之后第一时间执行。 处在window的load事件之前。 加载和渲染同步执行

     他们两个的差别在于脚本下载之后何时执行。 







### 网页的加载流程

* 1 解析HTML结构
* 2 加载外部脚本和样式表文件 解析成 CSSOM 树
* 3 解析并执行脚本代码  // 部分脚本会阻塞页面的加载
* 4 DOM树构建完成。 // DOMContentLoaded事件
* 5 加载图片等外部文件
* 6 页面加载完成 // load事件



**优化网页的加载速度本质的方法就是： 减少请求数量和减小请求大小**



* 图标合并 或字体图标

* base64减少不必要的网络请求

  **webpack里面的url-loader 加载器会智能的判断图片是否能装换成base64。8KB**

  base64就是将一副图片的数据编码成一串字符串。使用字符串代替图像地址。这样就可以不用像服务器请求了。那么base64跟雪碧图有什么区别？又怎么取舍呢？

  * 如果图片足够小 且用处的特殊性无法被制作成雪碧图。整个网站的复用性很高且基本不会被更新。
  * 相反如果你把大图片转换成base64 那么他的字符会很大。这样会CRP的阻塞。关键渲染路径

* 图片延迟加载

* js/css 按需打包加载

  ​



#### 减少请求大小 

*  js/css/html 压缩
* js/css 按需加载 （）
* 图片优化 webp图片等等