##### JavaScript 深入词法作用域和动态作用域

作用域是源代码中定义变量的区域

作用域规定了如何查找变量

JavaScript采用词法作用域 也就是静态作用域



**js采用词法作用域 函数的作用域在定义的时候就确定了** 词法作用域是相对动态作用域。函数的作用域是函数调用的时候才决定的。

```javascript
  var value = 1;

  function foo() {
    console.log(value);
  }

  function bar() {
    var value = 2;
    foo();
  }
  bar(); // 1
```

假设JavaScript采用静态作用域，让我们分析下执行过程：

执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。假设JavaScript采用动态作用域，让我们分析下执行过程：

执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。JavaScript采用的是静态作用域，所以这个例子的结果是 1。



##### JavaScript 权威指南

```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope(); // local scope

var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()(); // local scope
```

JavaScript权威指南》的回答就是：

JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。

虽然上面代码的结果一样 但是他们之间是不同的。执行上下文栈



##### 函数上下文

在函数上下文中 我们用 活动对象来表示变量对象

活动对象和变量对象其实是一个东西。 只有当进入到一个执行上下文中 这个执行上下文的变量对象才会被激活。 所以叫activation object。而只有被激活的变量对象。也就是活动对象属性才能被访问。

活动对象是在进入上下文时刻被创建的。通过函数的arguments属性初始化。 

```javascript
console.log(foo);

function foo() {
  console.log('foo');
}
var foo = 1;
```

在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。